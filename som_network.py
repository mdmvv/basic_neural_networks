"""
Neural network of self-organizing Kohonen maps (SOM).
It is trained on a set of images and can recognize samples with different pixel changes, outputting the percentage of
correctly recognized samples for each case of pixel changes.
"""


import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb
import math
import pandas as pd

I0 = np.array([[ 1,  1,  1,  1,  1,
				-1, -1, -1,  1, -1,
				-1, -1,  1, -1, -1,
				-1,  1, -1, -1, -1,
				 1,  1,  1,  1,  1], # Z
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1,  1,
				 1, -1, -1, -1,  1,
				 1, -1, -1, -1,  1], # A
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1,  1,
				 1, -1, -1, -1,  1,
				 1, -1, -1, -1,  1], # A
			   [ 1, -1, -1, -1,  1,
				 1,  1, -1, -1,  1,
				 1, -1,  1, -1,  1,
				 1, -1, -1,  1,  1,
				 1, -1, -1, -1,  1], # N
			   [ 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1, -1], # B
			   [ 1, -1, -1, -1,  1,
				-1,  1, -1,  1, -1,
				-1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1], # Y
			   [-1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1], # _
			   [ 1, -1, -1, -1,  1,
				 1,  1, -1, -1,  1,
				 1, -1,  1, -1,  1,
				 1, -1, -1,  1,  1,
				 1, -1, -1, -1,  1], # N
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1,
				 1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1], # E
			   [ 1,  1,  1,  1,  1,
				-1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1], # T
			   [ 1, -1,  1, -1,  1,
				 1, -1,  1, -1,  1,
				 1, -1,  1, -1,  1,
				 1, -1,  1, -1,  1,
				 1,  1,  1,  1,  1], # W
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1, -1,  1,
				 1, -1, -1, -1,  1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1,  1], # O
			   [ 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				 1, -1, -1, -1,  1], # R
			   [ 1, -1, -1, -1,  1,
				 1, -1, -1,  1, -1,
				 1,  1,  1, -1, -1,
				 1, -1, -1,  1, -1,
				 1, -1, -1, -1,  1]  # K
				])

I2 = np.array([[ 1,  1,  1,  1,  1,
				-1, -1, -1,  1, -1,
				-1, -1, -1, -1, -1,
				-1,  1, -1, -1, -1,
				-1,  1,  1,  1,  1], # Z
			   [ 1,  1,  1, -1,  1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1,  1,
				 1,  1, -1, -1,  1,
				 1, -1, -1, -1,  1], # A
			   [ 1,  1,  1,  1,  1,
				 1, -1,  1, -1,  1,
				 1,  1,  1,  1,  1,
				 1,  1, -1, -1,  1,
				 1, -1, -1, -1,  1], # A
			   [ 1, -1, -1, -1,  1,
				 1,  1, -1, -1,  1,
				 1, -1,  1, -1,  1,
				 1, -1, -1,  1, -1,
				 1, -1, -1, -1, -1], # N
			   [ 1,  1,  1, -1, -1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1, -1,
				 1, -1,  1, -1,  1,
				 1,  1,  1,  1, -1], # B
			   [ 1, -1, -1, -1,  1,
				-1,  1, -1,  1, -1,
				-1, -1,  1, -1, -1,
				-1,  1,  1, -1, -1,
				-1,  1,  1, -1, -1], # Y
			   [-1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1,
				-1, -1, -1,  1, -1,
				-1, -1, -1, -1, -1,
				 1, -1,  1,  1,  1], # _
			   [ 1, -1, -1, -1,  1,
				-1,  1, -1, -1,  1,
				 1, -1,  1,  1,  1,
				 1, -1, -1,  1,  1,
				 1, -1, -1, -1,  1], # N
			   [ 1, -1,  1,  1, -1,
				 1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1,
				 1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1], # E
			   [ 1,  1,  1,  1,  1,
				-1,  1,  1, -1, -1,
				 1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1,
				-1, -1,  1, -1, -1], # T
			   [ 1, -1,  1,  1,  1,
				 1, -1,  1, -1, -1,
				 1, -1,  1, -1,  1,
				 1, -1,  1, -1,  1,
				 1,  1,  1,  1,  1], # W
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1, -1, -1,
				 1, -1, -1, -1,  1,
				-1, -1, -1, -1,  1,
				 1,  1,  1,  1,  1], # O
			   [ 1, -1,  1,  1,  1,
				 1, -1, -1, -1,  1,
				 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				 1, -1, -1, -1,  1], # R
			   [ 1, -1, -1, -1,  1,
				 1, -1, -1,  1, -1,
				 1,  1,  1, -1, -1,
				-1, -1,  1,  1, -1,
				 1, -1, -1, -1,  1]  # K
				])

I4 = np.array([[-1,  1,  1,  1,  1,
				-1, -1, -1,  1, -1,
				-1, -1, -1, -1, -1,
				-1,  1, -1, -1, -1,
				-1,  1,  1,  1, -1], # Z
			   [ 1,  1,  1, -1,  1,
				 1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1,
				 1,  1, -1, -1, -1,
				 1, -1, -1, -1,  1], # A
			   [ 1,  1,  1,  1,  1,
				 1, -1,  1, -1, -1,
				-1,  1,  1,  1,  1,
				 1,  1, -1, -1,  1,
				 1, -1, -1, -1,  1], # A
			   [ 1, -1, -1, -1,  1,
				 1,  1, -1, -1,  1,
				-1, -1, -1, -1,  1,
				 1, -1, -1,  1, -1,
				 1, -1, -1, -1, -1], # N
			   [ 1,  1,  1, -1, -1,
				 1, -1, -1, -1,  1,
				 1, -1, -1,  1, -1,
				 1, -1,  1, -1,  1,
				 1,  1,  1,  1, -1], # B
			   [ 1, -1, -1, -1,  1,
				-1,  1, -1,  1, -1,
				-1, -1,  1, -1, -1,
				-1,  1,  1,  1, -1,
				-1,  1,  1,  1, -1], # Y
			   [-1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1,
				 1,  1, -1,  1, -1,
				-1, -1, -1, -1, -1,
				 1, -1,  1,  1,  1], # _
			   [ 1, -1, -1, -1,  1,
				-1,  1, -1, -1,  1,
				 1,  1,  1,  1,  1,
				 1, -1, -1,  1,  1,
				 1, -1,  1, -1,  1], # N
			   [-1, -1,  1,  1, -1,
				 1, -1, -1, -1, -1,
				-1,  1,  1,  1,  1,
				 1, -1, -1, -1, -1,
				 1,  1,  1,  1,  1], # E
			   [ 1,  1,  1,  1,  1,
				-1,  1,  1, -1, -1,
				 1, -1,  1, -1, -1,
				-1,  1,  1,  1, -1,
				-1, -1,  1, -1, -1], # T
			   [ 1, -1,  1,  1,  1,
				 1, -1,  1, -1, -1,
				 1, -1,  1, -1,  1,
				 1,  1,  1, -1,  1,
				 1,  1, -1,  1,  1], # W
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1, -1, -1,
				 1, -1, -1, -1,  1,
				-1, -1, -1,  1,  1,
				 1, -1,  1,  1,  1], # O
			   [ 1, -1,  1,  1,  1,
				-1, -1, -1, -1,  1,
				 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				-1, -1, -1, -1,  1], # R
			   [ 1, -1, -1, -1,  1,
				 1, -1,  1,  1, -1,
				 1,  1,  1, -1, -1,
				-1, -1,  1,  1, -1,
				 1, -1,  1, -1,  1]  # K
				])

I6 = np.array([[-1,  1,  1,  1,  1,
				-1,  1, -1,  1, -1,
				-1, -1, -1,  1, -1,
				-1,  1, -1, -1, -1,
				-1,  1,  1,  1, -1], # Z
			   [ 1,  1,  1, -1,  1,
				 1, -1, -1, -1, -1,
				 1,  1,  1, -1,  1,
				 1,  1, -1, -1, -1,
				 1, -1, -1, -1, -1], # A
			   [ 1,  1,  1,  1,  1,
				 1, -1,  1, -1, -1,
				-1,  1,  1,  1, -1,
				-1,  1, -1, -1,  1,
				 1, -1, -1, -1,  1], # A
			   [ 1, -1, -1, -1,  1,
				 1,  1, -1, -1,  1,
				-1, -1, -1, -1,  1,
				 1, -1,  1,  1, -1,
				-1, -1, -1, -1, -1], # N
			   [ 1,  1,  1, -1, -1,
				 1, -1, -1,  1,  1,
				 1, -1, -1,  1, -1,
				 1,  1,  1, -1,  1,
				 1,  1,  1,  1, -1], # B
			   [ 1, -1, -1, -1,  1,
				-1,  1, -1,  1,  1,
				-1, -1,  1, -1,  1,
				-1,  1,  1,  1, -1,
				-1,  1,  1,  1, -1], # Y
			   [-1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1,
				 1,  1, -1,  1, -1,
				-1,  1, -1,  1, -1,
				 1, -1,  1,  1,  1], # _
			   [ 1, -1, -1, -1,  1,
				-1, -1, -1, -1,  1,
				 1,  1,  1,  1,  1,
				 1, -1, -1,  1, -1,
				 1, -1,  1, -1,  1], # N
			   [-1, -1,  1,  1, -1,
				 1, -1, -1, -1, -1,
				-1,  1,  1,  1, -1,
				 1, -1, -1, -1, -1,
				 1,  1,  1, -1,  1], # E
			   [ 1,  1,  1,  1, -1,
				-1,  1,  1, -1, -1,
				 1, -1,  1, -1, -1,
				-1,  1,  1,  1,  1,
				-1, -1,  1, -1, -1], # T
			   [-1, -1,  1,  1,  1,
				 1, -1,  1, -1, -1,
				 1, -1,  1, -1,  1,
				-1,  1,  1, -1,  1,
				 1,  1, -1,  1,  1], # W
			   [ 1,  1,  1,  1,  1,
				 1, -1, -1,  1, -1,
				 1, -1,  1, -1,  1,
				-1, -1, -1,  1,  1,
				 1, -1,  1,  1,  1], # O
			   [ 1, -1,  1,  1,  1,
				-1, -1, -1, -1, -1,
				 1,  1,  1,  1, -1,
				 1, -1, -1, -1,  1,
				-1, -1, -1,  1,  1], # R
			   [ 1, -1, -1, -1,  1,
				 1, -1,  1, -1, -1,
				 1,  1,  1, -1, -1,
				-1, -1,  1,  1, -1,
				 1, -1,  1,  1,  1]  # K
				])

coord = np.array(
	[
		[0, 0], [0, 1], [0, 2], [0, 3],
		[1, 0], [1, 1], [1, 2], [1, 3],
		[2, 0], [2, 1], [2, 2], [2, 3],
		[3, 0], [3, 1], [3, 2], [3, 3]
	]
)

W = np.random.uniform(0, 1, (16, 25))

eta0 = 0.1
tau2 = 1000
sg = 2


def tau1():
	return 1000 / np.log(sg)


def eta(n):
	return eta0 * np.exp(-n / tau2)


def sgn(n):
	return sg * np.exp(-n / tau1())


def h(n, i, j):
	return np.exp(-np.power(-np.linalg.norm(coord[i] - coord[j]), 2) / (2 * np.power(sgn(n), 2)))


def test(I, W):
	T = []
	for q in range(len(I)):
		n = 15
		min = np.linalg.norm(I[q] - W[15])
		for i in range(15):
			j = np.linalg.norm(I[q] - W[i])
			if j < min:
				min = j
				n = i
		T.append(n)
	return T


f0, ax = plt.subplots(1, len(I0), figsize=(14, 1))
for i in range(len(I0)):
	sb.heatmap(np.reshape(I0[i], (5, 5)), cmap=sb.light_palette("red"), ax=ax[i], cbar=False, yticklabels=False, xticklabels=False)

f2, ax = plt.subplots(1, len(I2), figsize=(14, 1))
for i in range(len(I2)):
	sb.heatmap(np.reshape(I2[i], (5, 5)), cmap=sb.light_palette("green"), ax=ax[i], cbar=False, yticklabels=False, xticklabels=False)

f4, ax = plt.subplots(1, len(I4), figsize=(14, 1))
for i in range(len(I4)):
	sb.heatmap(np.reshape(I4[i], (5, 5)), cmap=sb.light_palette("blue"), ax=ax[i], cbar=False, yticklabels=False, xticklabels=False)

f6, ax = plt.subplots(1, len(I6), figsize=(14, 1))
for i in range(len(I6)):
	sb.heatmap(np.reshape(I6[i], (5, 5)), cmap=sb.light_palette("purple"), ax=ax[i], cbar=False, yticklabels=False, xticklabels=False)

plt.show()


for k in range(1000):
	x = np.random.randint(12)
	min = np.linalg.norm(I0[x] - W[15])
	n = 15
	for i in range(15):
		j = np.linalg.norm(I0[x] - W[i])
		if j < min:
			min = j
			n = i
	for z in range(len(W)):
		W[z] = W[z] + eta(k) * h(k, n, z) * (I0[x] - W[z])

for k in range(8000):
	x = np.random.randint(12)
	min = np.linalg.norm(I0[x] - W[11])
	n = 15
	for i in range(15):
		j = np.linalg.norm(I0[x] - W[i])
		if j < min:
			min = j
			n = i
	for z in range(len(W)):
		W[z] = W[z] + 0.1 * h(k, n, z) * (I0[x] - W[z])


test0 = test(I0, W)
test2 = test(I2, W)
test4 = test(I4, W)
test6 = test(I6, W)

er2 = []
er4 = []
er6 = []


for n in range(len(I0)):
	ht0 = []
	ht2 = []
	ht4 = []
	ht6 = []

	x0 = I0[n]
	x2 = I2[n]
	x4 = I4[n]
	x6 = I6[n]

	num = 0
	n0 = test0[n]
	i, j = 0, 0
	for i in range(4):
		ht0.append([])
		for j in range(4):
			ht0[i].append(h(k, n0, num))
			num += 1

	num = 0
	n2 = test2[n]
	n4 = test4[n]
	n6 = test6[n]
	i, j = 0, 0

	for i in range(4):
		ht2.append([])
		ht4.append([])
		ht6.append([])
		for j in range(4):
			ht2[i].append(h(k, n2, num))
			ht4[i].append(h(k, n4, num))
			ht6[i].append(h(k, n6, num))
			num += 1

	if ht0 == ht2: er2.append(1)
	else: er2.append(0)

	if ht0 == ht4: er4.append(1)
	else: er4.append(0)

	if ht0 == ht6: er6.append(1)
	else: er6.append(0)


word = ["Z", "A", "A", "N", "B", "Y", "_", "N", "E", "T", "W", "O", "R", "K"]
df = pd.DataFrame(
	data=list(zip(er2, er4, er6)),
	index=word,
	columns=["2 changed pixels", "4 changed pixels", "6 changed pixels"]
)

for col in df.columns:
	df[col] = df[col].map({1: True, 0: False})


print(df)
print()
print("2 changed pixels")
print("correct percent: %.2f" % (er2.count(1) / 14 * 100))
print()
print("4 changed pixels")
print("correct percent: %.2f" % (er4.count(1) / 14 * 100))
print()
print("6 changed pixels")
print("correct percent: %.2f" % (er6.count(1) / 14 * 100))
